# time is an rfc 3339 timestamp
scalar Time
# Map is a k/v map where the key is a string and the value is any value
scalar Map

type HTTPRoute {
    # The name assigned to the route for debugging purposes
    name: String!
    # forward to specific port on application
    port: Int!
    # prefix-based path match
    path_prefix: String
    # rewrite HTTP URIs before they reach the application
    rewrite_uri: String
    # The list of origins that are allowed to perform CORS requests
    allow_origins: [String!]
    # The list of methods that are allowed to perform CORS requests
    allow_methods: [String!]
    # The list of headers that are allowed to perform CORS requests
    allow_headers: [String!]
    #
    expose_headers: [String!]
    # adds `Access-Control-Allow-Credentials` header
    allow_credentials: Boolean
}

type Routing {
    #  The names of gateways and sidecars that should apply these routes.
    # Gateways in other projects may be referred to by
    # `<gateway project>/<gateway name>`; specifying a gateway with no
    # project qualifier is the same as specifying the VirtualService's
    # project. A single VirtualService is used for sidecars inside the mesh as
    # well as for one or more gateways. The selection condition imposed by this
    # field can be overridden using the source field in the match conditions
    # of protocol-specific routes. The reserved word `mesh` is used to imply
    # all the sidecars in the mesh. When this field is omitted, the default
    # gateway (`mesh`) will be used, which would apply the rule to all
    # sidecars in the mesh. If a list of gateway names is provided, the
    # rules will apply only to the gateways. To apply the rules to both
    # gateways and sidecars, specify `mesh` as one of the gateway names.
    gateways: [String!]
    # The destination hosts to which traffic is being sent. Could
    # be a DNS name with wildcard prefix or an IP address.
    hosts: [String!]
    # export to all other projects in service mesh
    export: Boolean
    # An ordered list of route rules for HTTP traffic
    http_routes: [HTTPRoute!]
}

input HTTPRouteInput {
    # The name assigned to the route for debugging purposes
    name: String!
    # forward to specific port on application
    port: Int!
    # prefix-based path match
    path_prefix: String
    # rewrite HTTP URIs before they reach the application
    rewrite_uri: String
    # The list of origins that are allowed to perform CORS requests
    allow_origins: [String!]
    # The list of methods that are allowed to perform CORS requests
    allow_methods: [String!]
    # The list of headers that are allowed to perform CORS requests
    allow_headers: [String!]
    #
    expose_headers: [String!]
    # adds `Access-Control-Allow-Credentials` header
    allow_credentials: Boolean
}

input RoutingInput {
    #  The names of gateways and sidecars that should apply these routes.
    # Gateways in other projects may be referred to by
    # `<gateway project>/<gateway name>`; specifying a gateway with no
    # project qualifier is the same as specifying the VirtualService's
    # project. A single VirtualService is used for sidecars inside the mesh as
    # well as for one or more gateways. The selection condition imposed by this
    # field can be overridden using the source field in the match conditions
    # of protocol-specific routes. The reserved word `mesh` is used to imply
    # all the sidecars in the mesh. When this field is omitted, the default
    # gateway (`mesh`) will be used, which would apply the rule to all
    # sidecars in the mesh. If a list of gateway names is provided, the
    # rules will apply only to the gateways. To apply the rules to both
    # gateways and sidecars, specify `mesh` as one of the gateway names.
    gateways: [String!]
    # The destination hosts to which traffic is being sent. Could
    # be a DNS name with wildcard prefix or an IP address.
    hosts: [String!]
    #
    export: Boolean
    #
    http_routes: [HTTPRouteInput!]
}


type Container {
    name: String!
    # docker image of application
    image: String!
    # args are arguments given to the container/image at startup
    args: [String!]
    # k/v map of environmental variables
    env: Map
    # k/v map of ports to expose ex: http-1: 80 https-1: 443
    ports: Map!
}

input ContainerInput {
    name: String!
    # docker image of application
    image: String!
    # args are arguments given to the container/image at startup
    args: [String!]
    # k/v map of environmental variables
    env: Map
    # k/v map of ports to expose ex: http-1: 80 https-1: 443
    ports: Map!
}

# App is a stateless application
type App {
    # name of the application
    name: String!
    containers: [Container!]!
    # number of deployment replicas min:1
    replicas: Int!
    # gateway/service mesh routing
    routing: Routing!
    # status tracks the state of the application during it's lifecycle
    status: AppStatus!
    

}

# Task is scheduled cron job
type Task {
    # name of the application
    name: String!
    containers: [Container!]!
    # schedule is the cron schedule: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/
    schedule: String!
    # completions is the number of times to execute the task. If completions = 0, the task will run forever
    completions: Int
    

}

# Replica tracks the state of a single instance
type Replica {
    phase: String!
    condition: String!
    reason: String!
}

# AppStatus tracks the state of an app's lifecycle
type AppStatus {
    replicas: [Replica]!
}

# Log is a message streamed from stdout/stderr of an instance
type Log {
    message: String!
}

# AppInput creates a new stateless Application
input AppInput {
    # name of the application
    name: String!
    containers: [ContainerInput!]!
    # number of deployment replicas min:1
    replicas: Int!
    # gateway/servicemesh configuration
    routing: RoutingInput!
}

# TaskInput creates a new task(cron job)
input TaskInput {
    # name of the application
    name: String!
    containers: [ContainerInput!]!
    # schedule is the cron schedule: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/
    schedule: String!
    # completions is the number of times to execute the task. If completions = 0, the task will run forever
    completions: Int
    

}

input Ref {
    # name of the resource
    name: String!
}

type Mutation {
    # delProject deletes all resources within an existing project
    delProject(input: String): String
    # createApp creates a new stateless application(k8s deployment), exposed with a single load balancer(k8s service) within a single project(k8s project)
    createApp(input: AppInput!): App!
    # updateApp edits/patches an existing stateless application(k8s deployment & service) within an existing project(k8s project)
    updateApp(input: AppInput!): App!
    # delApp deletes a single stateless application(k8s deployment & service) within an existing project
    delApp(input: Ref!): String
    # createTask creates a new task(k8s cron job) within a single project(k8s project)
    createTask(input: TaskInput!): Task!
    #  UpdateTask edits/patches an existing task(k8s cron job) within an existing project(k8s project)
    updateTask(input: TaskInput!): Task!
    # DeleteTask deletes a single task(k8s cron job) within an existing project
    delTask(input: Ref!): String


}

type Query {
    # getApp gets an existing stateless application(k8s deployment) by name within an existing project
    getApp(input: Ref!): App
    # listApps lists all an existing stateless applications(k8s deployments) within an existing project
    listApps(input: String): [App!]

    # getTask gets a task(k8s cron job) by name within an existing project
    getTask(input: Ref!): Task
    # listTasks lists all tasks(k8s cron jobs) within an existing project
    listTasks(input: String): [Task!]

}

type Subscription {
    # logs streams logs from an an existing stateless application(k8s deployment) within an existing project. Streams are opened to all replicas & converted into a single stream
    streamLogs(input: Ref!): String!
}
