# time is an rfc 3339 timestamp
scalar Time
# Map is a k/v map where the key is a string and the value is any value
scalar Map

type HTTPRoute {
    # The name assigned to the route for debugging purposes
    name: String
    # forward to specific port on application
    port: Int
    # prefix-based path match
    path_prefix: String
    # rewrite HTTP URIs before they reach the application
    rewrite_uri: String
    # The list of origins that are allowed to perform CORS requests
    allow_origins: [String!]
    # The list of methods that are allowed to perform CORS requests
    allow_methods: [String!]
    # The list of headers that are allowed to perform CORS requests
    allow_headers: [String!]
    #
    expose_headers: [String!]
    # adds `Access-Control-Allow-Credentials` header
    allow_credentials: Boolean
}

type Networking {
    #  The names of gateways and sidecars that should apply these routes.
    # Gateways in other namespaces may be referred to by
    # `<gateway namespace>/<gateway name>`; specifying a gateway with no
    # namespace qualifier is the same as specifying the VirtualService's
    # namespace. A single VirtualService is used for sidecars inside the mesh as
    # well as for one or more gateways. The selection condition imposed by this
    # field can be overridden using the source field in the match conditions
    # of protocol-specific routes. The reserved word `mesh` is used to imply
    # all the sidecars in the mesh. When this field is omitted, the default
    # gateway (`mesh`) will be used, which would apply the rule to all
    # sidecars in the mesh. If a list of gateway names is provided, the
    # rules will apply only to the gateways. To apply the rules to both
    # gateways and sidecars, specify `mesh` as one of the gateway names.
    gateways: [String!]
    # The destination hosts to which traffic is being sent. Could
    # be a DNS name with wildcard prefix or an IP address.
    hosts: [String!]
    # export to all other namespaces in service mesh
    export: Boolean
    # An ordered list of route rules for HTTP traffic
    http_routes: [HTTPRoute!]
}

input HTTPRouteInput {
    # The name assigned to the route for debugging purposes
    name: String
    # forward to specific port on application
    port: Int
    # prefix-based path match
    path_prefix: String
    # rewrite HTTP URIs before they reach the application
    rewrite_uri: String
    # The list of origins that are allowed to perform CORS requests
    allow_origins: [String!]
    # The list of methods that are allowed to perform CORS requests
    allow_methods: [String!]
    # The list of headers that are allowed to perform CORS requests
    allow_headers: [String!]
    #
    expose_headers: [String!]
    # adds `Access-Control-Allow-Credentials` header
    allow_credentials: Boolean
}

input NetworkingInput {
    #  The names of gateways and sidecars that should apply these routes.
    # Gateways in other namespaces may be referred to by
    # `<gateway namespace>/<gateway name>`; specifying a gateway with no
    # namespace qualifier is the same as specifying the VirtualService's
    # namespace. A single VirtualService is used for sidecars inside the mesh as
    # well as for one or more gateways. The selection condition imposed by this
    # field can be overridden using the source field in the match conditions
    # of protocol-specific routes. The reserved word `mesh` is used to imply
    # all the sidecars in the mesh. When this field is omitted, the default
    # gateway (`mesh`) will be used, which would apply the rule to all
    # sidecars in the mesh. If a list of gateway names is provided, the
    # rules will apply only to the gateways. To apply the rules to both
    # gateways and sidecars, specify `mesh` as one of the gateway names.
    gateways: [String!]
    # The destination hosts to which traffic is being sent. Could
    # be a DNS name with wildcard prefix or an IP address.
    hosts: [String!]
    #
    export: Boolean
    #
    http_routes: [HTTPRouteInput!]
}

# App is a stateless application
type App {
    # name of the application
    name: String!
    # application namespace
    namespace: String!
    # docker image of application
    image: String!
    # args are arguments given to the container/image at startup
    args: [String!]
    # k/v map of environmental variables
    env: Map
    # k/v map of ports to expose ex: http: 80 https: 443
    ports: Map!
    # number of deployment replicas min:1
    replicas: Int!
    # gateway/service mesh networking
    networking: Networking!
    # status tracks the state of the application during it's lifecycle
    status: AppStatus!
}

# Task is scheduled cron job
type Task {
    # name of the application
    name: String!
    # application namespace
    namespace: String!
    # docker image of application
    image: String!
    # args are arguments given to the container/image at startup
    args: [String!]
    # k/v map of environmental variables
    env: Map
    # schedule is the cron schedule: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/
    schedule: String!
    # completions is the number of times to execute the task. If completions = 0, the task will run forever
    completions: Int
}

# Replica tracks the state of a single instance
type Replica {
    phase: String!
    condition: String!
    reason: String!
}

# AppStatus tracks the state of an app's lifecycle
type AppStatus {
    replicas: [Replica]!
}

# Log is a message streamed from stdout/stderr of an instance
type Log {
    message: String!
}

# Namespaces is a list of namespaces
type Namespaces {
    namespaces: [String!]
}

# Namespace is a primitive used for logical segmentation of apps & tasks
input Namespace {
    namespace: String!
}

# AppInput creates a new stateless Application
input AppInput {
    # name of the application
    name: String!
    # application namespace
    namespace: String!
    # docker image of application
    image: String!
    # args are arguments given to the container/image at startup
    args: [String!]
    # k/v map of environmental variables
    env: Map
    # k/v map of ports to expose ex: http-1: 80 https-1: 443
    ports: Map!
    # number of deployment replicas min:1
    replicas: Int!
    # gateway/servicemesh configuration
    networking: NetworkingInput!
}

# TaskInput creates a new task(cron job)
input TaskInput {
    # name of the application
    name: String!
    # application namespace
    namespace: String!
    # docker image of application
    image: String!
    # args are arguments given to the container/image at startup
    args: [String!]
    # k/v map of environmental variables
    env: Map
    # schedule is the cron schedule: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/
    schedule: String!
    # completions is the number of times to execute the task. If completions = 0, the task will run forever
    completions: Int
}

input Ref {
    # name of the application
    name: String!
    # application namespace
    namespace: String!
}


type Mutation {
    # createApp creates a new stateless application(k8s deployment), exposed with a single load balancer(k8s service) within a single namespace(k8s namespace)
    # the namespace will automatically be created if one does not already exist
    createApp(input: AppInput!): App!
    # updateApp edits/patches an existing stateless application(k8s deployment & service) within an existing namespace(k8s namespace)
    updateApp(input: AppInput!): App!
    # delApp deletes a single stateless application(k8s deployment & service) within an existing namespace
    delApp(input: Ref!): String
    # createTask creates a new task(k8s cron job) within a single namespace(k8s namespace)
    # the namespace will automatically be created if one does not already exist
    createTask(input: TaskInput!): Task!
    #  UpdateTask edits/patches an existing task(k8s cron job) within an existing namespace(k8s namespace)
    updateTask(input: TaskInput!): Task!
    # DeleteTask deletes a single task(k8s cron job) within an existing namespace
    delTask(input: Ref!): String
    # delAll deletes all apps/tasks within an existing namespace
    delAll(input: Namespace!): String
}

type Query {
    # getApp gets an existing stateless application(k8s deployment) by name within an existing namespace
    getApp(input: Ref!): App
    # listApps lists all an existing stateless applications(k8s deployments) within an existing namespace
    listApps(input: Namespace!): [App!]
    # getTask gets a task(k8s cron job) by name within an existing namespace
    getTask(input: Ref!): Task
    # listTasks lists all tasks(k8s cron jobs) within an existing namespace
    listTasks(input: Namespace!): [Task!]
    # listNamespaces lists all namespaces created by kdeploy
    listNamespaces(input: String): Namespaces!
}

type Subscription {
    # logs streams logs from an an existing stateless application(k8s deployment) within an existing namespace. Streams are opened to all replicas & converted into a single stream
    streamLogs(input: Ref!): String!
}
