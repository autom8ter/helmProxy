# time is an rfc 3339 timestamp
scalar Time
# Map is a k/v map where the key is a string and the value is any value
scalar Map

type HTTPRoute {
    # The name assigned to the route for debugging purposes
    name: String!
    # forward to specific port on application
    port: Int!
    # prefix-based path match
    path_prefix: String
    # rewrite HTTP URIs before they reach the application
    rewrite_uri: String
    # The list of origins that are allowed to perform CORS requests
    allow_origins: [String!]
    # The list of methods that are allowed to perform CORS requests
    allow_methods: [String!]
    # The list of headers that are allowed to perform CORS requests
    allow_headers: [String!]
    #
    expose_headers: [String!]
    # adds `Access-Control-Allow-Credentials` header
    allow_credentials: Boolean
}

type Routing {
    # The gateway to bind to
    gateway: String
    # The destination hosts to which traffic is being sent. Could
    # be a DNS name with wildcard prefix or an IP address.
    hosts: [String!]
    # An ordered list of route rules for HTTP traffic
    http_routes: [HTTPRoute!]
}

input HTTPRouteInput {
    # The name assigned to the route for debugging purposes
    name: String!
    # forward to specific port on application
    port: Int!
    # prefix-based path match
    path_prefix: String
    # rewrite HTTP URIs before they reach the application
    rewrite_uri: String
    # The list of origins that are allowed to perform CORS requests
    allow_origins: [String!]
    # The list of methods that are allowed to perform CORS requests
    allow_methods: [String!]
    # The list of headers that are allowed to perform CORS requests
    allow_headers: [String!]
    #
    expose_headers: [String!]
    # adds `Access-Control-Allow-Credentials` header
    allow_credentials: Boolean
}

input RoutingInput {
    # the gateway to bind to
    gateway: String
    # The destination hosts to which traffic is being sent. Could
    # be a DNS name with wildcard prefix or an IP address.
    hosts: [String!]
    http_routes: [HTTPRouteInput!]
}


type Container {
    name: String!
    # docker image of application
    image: String!
    # args are arguments given to the container/image at startup
    args: [String!]
    # k/v map of environmental variables
    env: Map
    # k/v map of ports to expose ex: http-1: 80 https-1: 443
    ports: Map!
}

input ContainerInput {
    name: String!
    # docker image of application
    image: String!
    # args are arguments given to the container/image at startup
    args: [String!]
    # k/v map of environmental variables
    env: Map
    # k/v map of ports to expose ex: http-1: 80 https-1: 443
    ports: Map!
}

# App is a stateless application
type App {
    # name of the application
    name: String!
    containers: [Container!]!
    # number of deployment replicas min:1
    replicas: Int!
    # gateway/service mesh routing
    routing: Routing!
    # status tracks the state of the application during it's lifecycle
    status: AppStatus!
    

}

# Task is scheduled cron job
type Task {
    # name of the application
    name: String!
    containers: [Container!]!
    # schedule is the cron schedule: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/
    schedule: String!
    # completions is the number of times to execute the task. If completions = 0, the task will run forever
    completions: Int
    

}

# Replica tracks the state of a single instance
type Replica {
    phase: String!
    condition: String!
    reason: String!
}

# AppStatus tracks the state of an app's lifecycle
type AppStatus {
    replicas: [Replica]!
}

# Log is a message streamed from stdout/stderr of an instance
type Log {
    message: String!
}

# AppInput creates a new stateless Application
input AppInput {
    # name of the application
    name: String!
    containers: [ContainerInput!]!
    # number of deployment replicas min:1
    replicas: Int!
    # gateway/servicemesh configuration
    routing: RoutingInput!
}

# TaskInput creates a new task(cron job)
input TaskInput {
    # name of the application
    name: String!
    containers: [ContainerInput!]!
    # schedule is the cron schedule: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/
    schedule: String!
    # completions is the number of times to execute the task. If completions = 0, the task will run forever
    completions: Int
    

}

input Ref {
    # name of the resource
    name: String!
}

type Mutation {
    # delProject deletes all resources within an existing project
    delProject(input: String): String
    # createApp creates a new stateless application(k8s deployment), exposed with a single load balancer(k8s service) within a single project(k8s project)
    createApp(input: AppInput!): App!
    # updateApp edits/patches an existing stateless application(k8s deployment & service) within an existing project(k8s project)
    updateApp(input: AppInput!): App!
    # delApp deletes a single stateless application(k8s deployment & service) within an existing project
    delApp(input: Ref!): String
    # createTask creates a new task(k8s cron job) within a single project(k8s project)
    createTask(input: TaskInput!): Task!
    #  UpdateTask edits/patches an existing task(k8s cron job) within an existing project(k8s project)
    updateTask(input: TaskInput!): Task!
    # DeleteTask deletes a single task(k8s cron job) within an existing project
    delTask(input: Ref!): String


}

type Query {
    # getApp gets an existing stateless application(k8s deployment) by name within an existing project
    getApp(input: Ref!): App
    # listApps lists all an existing stateless applications(k8s deployments) within an existing project
    listApps(input: String): [App!]

    # getTask gets a task(k8s cron job) by name within an existing project
    getTask(input: Ref!): Task
    # listTasks lists all tasks(k8s cron jobs) within an existing project
    listTasks(input: String): [Task!]

}

type Subscription {
    # logs streams logs from an an existing stateless application(k8s deployment) within an existing project. Streams are opened to all replicas & converted into a single stream
    streamLogs(input: Ref!): String!
}
