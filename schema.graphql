# time is an rfc 3339 timestamp
scalar Time
# Map is a k/v map where the key is a string and the value is any value
scalar Map

type HTTPRoute {
    # The name assigned to the route for debugging purposes
    name: String!
    # forward to specific port on api
    port: Int!
    # prefix-based path match
    path_prefix: String
    # rewrite HTTP URIs before they reach the api
    rewrite_uri: String
    # The list of origins that are allowed to perform CORS requests
    allow_origins: [String!]
    # The list of methods that are allowed to perform CORS requests
    allow_methods: [String!]
    # The list of headers that are allowed to perform CORS requests
    allow_headers: [String!]
    #
    expose_headers: [String!]
    # adds `Access-Control-Allow-Credentials` header
    allow_credentials: Boolean
}

type Routing {
    # The gateway to bind to
    gateway: String
    # The destination hosts to which traffic is being sent. Could
    # be a DNS name with wildcard prefix or an IP address.
    hosts: [String!]
    # An ordered list of route rules for HTTP traffic
    http_routes: [HTTPRoute!]
}

input HTTPRouteInput {
    # The name assigned to the route for debugging purposes
    name: String!
    # forward to specific port on api
    port: Int!
    # prefix-based path match
    path_prefix: String
    # rewrite HTTP URIs before they reach the api
    rewrite_uri: String
    # The list of origins that are allowed to perform CORS requests
    allow_origins: [String!]
    # The list of methods that are allowed to perform CORS requests
    allow_methods: [String!]
    # The list of headers that are allowed to perform CORS requests
    allow_headers: [String!]
    #
    expose_headers: [String!]
    # adds `Access-Control-Allow-Credentials` header
    allow_credentials: Boolean
}

input RoutingInput {
    # the gateway to bind to
    gateway: String
    # The destination hosts to which traffic is being sent. Could
    # be a DNS name with wildcard prefix or an IP address.
    hosts: [String!]
    http_routes: [HTTPRouteInput!]
}

type ContainerPort {
    name: String!
    number: Int!
    expose: Boolean!
}

input ContainerPortInput {
    name: String!
    number: Int!
    expose: Boolean!
}

type Container {
    name: String!
    # docker image of api
    image: String!
    # args are arguments given to the container/image at startup
    args: [String!]
    # k/v map of environmental variables
    env: Map
    ports: [ContainerPort]
}

input ContainerInput {
    name: String!
    # docker image of api
    image: String!
    # args are arguments given to the container/image at startup
    args: [String!]
    # k/v map of environmental variables
    env: Map
    ports: [ContainerPortInput]
}

# API is a stateless api
type API {
    # name of the api
    name: String!
    containers: [Container!]!
    # number of deployment replicas min:1
    replicas: Int!
    # gateway/service mesh routing
    routing: Routing!
    # status tracks the state of the api during it's lifecycle
    status: APIStatus!
    

}

# Task is scheduled cron job
type Task {
    # name of the api
    name: String!
    containers: [Container!]!
    # schedule is the cron schedule: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/
    schedule: String!
    # completions is the number of times to execute the task. If completions = 0, the task will run forever
    completions: Int
    

}

# Replica tracks the state of a single instance
type Replica {
    phase: String!
    condition: String!
    reason: String!
}

# APIStatus tracks the state of an app's lifecycle
type APIStatus {
    replicas: [Replica]!
}

# Log is a message streamed from stdout/stderr of an instance
type Log {
    message: String!
}

# APIInput creates a new stateless API
input APIInput {
    # name of the api
    name: String!
    containers: [ContainerInput!]!
    # number of deployment replicas min:1
    replicas: Int!
    # gateway/servicemesh configuration
    routing: RoutingInput!
}

# TaskInput creates a new task(cron job)
input TaskInput {
    # name of the api
    name: String!
    containers: [ContainerInput!]!
    # schedule is the cron schedule: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/
    schedule: String!
    # completions is the number of times to execute the task. If completions = 0, the task will run forever
    completions: Int
    

}

input Ref {
    # name of the resource
    name: String!
}

input LogOpts {
    # name of the resource
    name: String!
    # container name
    container: String!
    # previous retrieves logs from the previous container than the one running(useful for restarts)
    previous: Boolean
    # the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or since_seconds
    tail_lines: Int
    # since_seconds streams since a certain unix time(in the past)
    since_seconds: Int
    # if stream is true, the tcp connection will be left open & logs will continue to be sent to the client
    stream: Boolean
}

type Mutation {
    # delProject deletes all resources within an existing project
    delProject(input: String): String
    # createAPI creates a new stateless api(k8s deployment), exposed with a single load balancer(k8s service) within a single project(k8s project)
    createAPI(input: APIInput!): API!
    # updateAPI edits/patches an existing stateless api(k8s deployment & service) within an existing project(k8s project)
    updateAPI(input: APIInput!): API!
    # delAPI deletes a single stateless api(k8s deployment & service) within an existing project
    delAPI(input: Ref!): String
    # createTask creates a new task(k8s cron job) within a single project(k8s project)
    createTask(input: TaskInput!): Task!
    #  UpdateTask edits/patches an existing task(k8s cron job) within an existing project(k8s project)
    updateTask(input: TaskInput!): Task!
    # DeleteTask deletes a single task(k8s cron job) within an existing project
    delTask(input: Ref!): String


}

type Query {
    # getAPI gets an existing stateless api(k8s deployment) by name within an existing project
    getAPI(input: Ref!): API
    # listAPIs lists all an existing stateless apis(k8s deployments) within an existing project
    listAPIs(input: String): [API!]

    # getTask gets a task(k8s cron job) by name within an existing project
    getTask(input: Ref!): Task
    # listTasks lists all tasks(k8s cron jobs) within an existing project
    listTasks(input: String): [Task!]


}

type Subscription {
    # logs streams logs from an an existing api/cronjob
    streamLogs(input: LogOpts!): String!
}
