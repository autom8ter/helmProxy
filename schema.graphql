# time is an rfc 3339 timestamp
scalar Time
# Map is a k/v map where the key is a string and the value is any value
scalar Map

type Route {
    hosts: [String!]
    gateways: [String!]
    path_prefix: String
    rewrite_uri: String
    allow_origins: [String!]
    allow_methods: [String!]
    allow_headers: [String!]
    expose_headers: [String!]
    allow_credentials: Boolean
}

type Networking {
    routes: [Route!]!
    export: Boolean
}

input RouteInput {
    hosts: [String!]
    gateways: [String!]
    path_prefix: String
    rewrite_uri: String
    allow_origins: [String!]
    allow_methods: [String!]
    allow_headers: [String!]
    expose_headers: [String!]
    allow_credentials: Boolean
}

input NetworkingInput {
    routes: [RouteInput!]!
    export: Boolean
}

# App is a stateless application
type App {
    # name of the application
    name: String!
    # application namespace
    namespace: String!
    # docker image of application
    image: String!
    # args are arguments given to the container/image at startup
    args: [String!]
    # k/v map of environmental variables
    env: Map
    # k/v map of ports to expose ex: http: 80 https: 443
    ports: Map!
    # number of deployment replicas min:1
    replicas: Int!
    networking: Networking!
    # status tracks the state of the application during it's lifecycle
    status: AppStatus!
}

# Task is scheduled cron job
type Task {
    # name of the application
    name: String!
    # application namespace
    namespace: String!
    # docker image of application
    image: String!
    # args are arguments given to the container/image at startup
    args: [String!]
    # k/v map of environmental variables
    env: Map
    # schedule is the cron schedule: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/
    schedule: String!
    # completions is the number of times to execute the task. If completions = 0, the task will run forever
    completions: Int
}

# Replica tracks the state of a single instance
type Replica {
    phase: String!
    condition: String!
    reason: String!
}

# AppStatus tracks the state of an app's lifecycle
type AppStatus {
    replicas: [Replica]!
}

# Log is a message streamed from stdout/stderr of an instance
type Log {
    message: String!
}

# Namespaces is a list of namespaces
type Namespaces {
    namespaces: [String!]
}

# Namespace is a primitive used for logical segmentation of apps & tasks
input Namespace {
    namespace: String!
}

# AppConstructor creates a new stateless Application
input AppConstructor {
    # name of the application
    name: String!
    # application namespace
    namespace: String!
    # docker image of application
    image: String!
    # args are arguments given to the container/image at startup
    args: [String!]
    # k/v map of environmental variables
    env: Map
    # k/v map of ports to expose ex: http: 80 https: 443
    ports: Map!
    # number of deployment replicas min:1
    replicas: Int!
    networking: NetworkingInput!
}

# TaskConstructor creates a new task(cron job)
input TaskConstructor {
    # name of the application
    name: String!
    # application namespace
    namespace: String!
    # docker image of application
    image: String!
    # args are arguments given to the container/image at startup
    args: [String!]
    # k/v map of environmental variables
    env: Map
    # schedule is the cron schedule: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/
    schedule: String!
    # completions is the number of times to execute the task. If completions = 0, the task will run forever
    completions: Int
}

input AppUpdate {
    # name of the application
    name: String!
    # application namespace
    namespace: String!
    # docker image of application
    image: String
    # args are arguments given to the container/image at startup
    args: [String!]
    # k/v map of environmental variables
    env: Map
    # k/v map of ports to expose ex: http: 80 https: 443
    ports: Map
    # number of deployment replicas min:1
    replicas: Int
    networking: NetworkingInput
}

input TaskUpdate {
    # name of the application
    name: String!
    # application namespace
    namespace: String!
    # docker image of application
    image: String
    # args are arguments given to the container/image at startup
    args: [String!]
    # k/v map of environmental variables
    env: Map
    # schedule is the cron schedule: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/
    schedule: String
    # completions is the number of times to execute the task. If completions = 0, the task will run forever
    completions: Int
}

input Ref {
    # name of the application
    name: String!
    # application namespace
    namespace: String!
}


type Mutation {
    # createApp creates a new stateless application(k8s deployment), exposed with a single load balancer(k8s service) within a single namespace(k8s namespace)
    # the namespace will automatically be created if one does not already exist
    createApp(input: AppConstructor!): App
    # updateApp edits/patches an existing stateless application(k8s deployment & service) within an existing namespace(k8s namespace)
    updateApp(input: AppUpdate!): App
    # delApp deletes a single stateless application(k8s deployment & service) within an existing namespace
    delApp(input: Ref!): String
    # createTask creates a new task(k8s cron job) within a single namespace(k8s namespace)
    # the namespace will automatically be created if one does not already exist
    createTask(input: TaskConstructor!): Task
    #  UpdateTask edits/patches an existing task(k8s cron job) within an existing namespace(k8s namespace)
    updateTask(input: TaskUpdate!): Task
    # DeleteTask deletes a single task(k8s cron job) within an existing namespace
    delTask(input: Ref!): String
    # delAll deletes all apps/tasks within an existing namespace
    delAll(input: Namespace!): String
}

type Query {
    # getApp gets an existing stateless application(k8s deployment) by name within an existing namespace
    getApp(input: Ref!): App
    # listApps lists all an existing stateless applications(k8s deployments) within an existing namespace
    listApps(input: Namespace!): [App!]
    # getTask gets a task(k8s cron job) by name within an existing namespace
    getTask(input: Ref!): Task
    # listTasks lists all tasks(k8s cron jobs) within an existing namespace
    listTasks(input: Namespace!): [Task!]
    # listNamespaces lists all namespaces created by kdeploy
    listNamespaces(input: String): Namespaces!
}

type Subscription {
    # logs streams logs from an an existing stateless application(k8s deployment) within an existing namespace. Streams are opened to all replicas & converted into a single stream
    streamLogs(input: Ref!): String!
}
