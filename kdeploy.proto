syntax = "proto3";

package kdeploy;

option go_package = "kdeploypb";

import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/any.proto";
import "google/protobuf/empty.proto";
import "github.com/mwitkow/go-proto-validators/validator.proto";

// Route is a single http route(istio HttpRoute)
message Route {
  string name =1[(validator.field) = {regex : "^.{1,225}$"}];
  uint32 port =2 [(validator.field) = {int_gt: 0}];
  string path_prefix =3;
  string rewrite_uri = 4;
  repeated string allow_origins =5;
  repeated string allow_methods =6;
  repeated string allow_headers =7;
  repeated string expose_headers =8;
  bool allow_credentials =9;
}

message Networking {
  repeated string gateways =1;
  repeated string hosts =2;
  bool export =3;
  repeated Route routes =4;
}

// App is a stateless application
message App {
  // name of the application
  string name =1;
  // application namespace
  string namespace =2;
  // docker image of application
  string image =3;
  // args are arguments given to the docker image at startup
  repeated string args =5;
  // k/v map of environmental variables
  map<string, string> env =6;
  // k/v map of ports to expose ex: http: 80 https: 443
  map<string, uint32> ports =7;
  // number of deployment replicas
  uint32 replicas =8;
  Networking networking =9;
  // status tracks the state of the application during it's lifecycle
  AppStatus status =20;
}


// Task is scheduled cron job
message Task {
  // name of the task
  string name =1;
  // task namespace
  string namespace =2;
  // docker image of task
  string image =3;
  // args are arguments given to docker image at startup
  repeated string args =5;
  // k/v map of environmental variables
  map<string, string> env =6;
  // schedule is the cron schedule: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/
  string schedule = 7;
  // completions is the number of times to execute the task. If completions = 0, the task will run forever
  uint32 completions = 8;
}

// TaskConstructor creates a task(cron job)
message TaskConstructor {
  // name of the task
  string name =1[(validator.field) = {regex : "^.{1,225}$"}];
  // task namespace
  string namespace =2[(validator.field) = {regex : "^.{1,225}$"}];
  // docker image of task
  string image =3[(validator.field) = {regex : "^.{1,225}$"}];
  // args are arguments given to docker image at startup
  repeated string args =5;
  // k/v map of environmental variables
  map<string, string> env =6;
  // schedule is the cron schedule: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/
  string schedule = 7[(validator.field) = {regex : "^.{1,225}$"}];
  // completions is the number of times to execute the task. If completions = 0, the task will run forever
  uint32 completions = 8;
}

// TaskUpdate updates a task(cron job)
message TaskUpdate {
  // name of the application
  string name =1[(validator.field) = {regex : "^.{1,225}$"}];
  // application namespace
  string namespace =2[(validator.field) = {regex : "^.{1,225}$"}];
  // docker image of application
  string image =3;
  // args are arguments given to docker image at startup
  repeated string args =5;
  // k/v map of environmental variables
  map<string, string> env =6;
  // schedule is the cron schedule: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/
  string schedule = 7;
  // completions is the number of times to execute the task. If completions = 0, the task will run forever
  uint32 completions = 8;
}

// AppConstructor creates a new app
message AppConstructor {
  // name of the application
  string name =1[(validator.field) = {regex : "^.{1,225}$"}];
  // application namespace
  string namespace =2[(validator.field) = {regex : "^.{1,225}$"}];
  // docker image of application
  string image =3[(validator.field) = {regex : "^.{1,225}$"}];
  // args are arguments given to the docker image at startup
  repeated string args =4;
  // k/v map of environmental variables
  map<string, string> env =5;
  // k/v map of ports to expose ex: http: 80 https: 443
  map<string, uint32> ports =6;
  // number of deployment replicas
  uint32 replicas =7;
  Networking networking =9[(validator.field) = {msg_exists : true}];
}

// AppUpdate updates an App
message AppUpdate {
  // name of the application
  string name =1[(validator.field) = {regex : "^.{1,225}$"}];
  // application namespace
  string namespace =2[(validator.field) = {regex : "^.{1,225}$"}];
  // docker image of application
  string image =3;
  // args are arguments given to the docker image at startup
  repeated string args =4;
  // k/v map of environmental variables
  map<string, string> env =5;
  // k/v map of ports to expose ex: http: 80 https: 443
  map<string, uint32> ports =6;
  // number of deployment replicas
  uint32 replicas =7;
  Networking networking =9;
}

message Ref {
  // name of the application
  string name =1[(validator.field) = {regex : "^.{1,225}$"}];
  // application namespace
  string namespace =2[(validator.field) = {regex : "^.{1,225}$"}];
}
//repeated_count_min

message Replica {
  string phase =1;
  string condition =2;
  string reason =3;
}

message AppStatus {
  repeated Replica replicas =1;
}

message Log {
  string message =1;
}

message Apps {
  repeated App applications =1;
}

message Tasks {
  repeated Task tasks =1;
}

message Namespace {
  string namespace =1;
}

message Namespaces {
  repeated string namespaces =1;
}


//
service KdeployService {
  // CreateApp creates a new stateless application(k8s deployment & service) within a single namespace(k8s namespace)
  // the namespace will automatically be created if one does not already exist
  rpc CreateApp(AppConstructor) returns(App){}
  // UpdateApp edits/patches an existing stateless application(k8s deployment & service) within an existing namespace(k8s namespace)
  rpc UpdateApp(AppUpdate) returns(App){}
  // DeleteApp deletes a single stateless application(k8s deployment & service) within an existing namespace
  rpc DeleteApp(Ref) returns(google.protobuf.Empty){}
  // GetApp gets an app by name within an existing namespace
  rpc GetApp(Ref) returns(App){}
  // ListApps lists all apps within an existing namespace
  rpc ListApps(Namespace) returns(Apps){}
  // ListNamespaces lists all namespaces created by kdeploy
  rpc ListNamespaces(google.protobuf.Empty) returns(Namespaces){}
  // DeleteAll deletes all apps/tasks within an existing namespace
  rpc DeleteAll(Namespace) returns(google.protobuf.Empty){}
  // CreateTask creates a new task(k8s cron job) within a single namespace(k8s namespace)
  // the namespace will automatically be created if one does not already exist
  rpc CreateTask(TaskConstructor) returns(Task){}
  // UpdateTask edits/patches an existing task(k8s cron job) within an existing namespace(k8s namespace)
  rpc UpdateTask(TaskUpdate) returns(Task){}
  // DeleteTask deletes a single task(k8s cron job) within an existing namespace
  rpc DeleteTask(Ref) returns(google.protobuf.Empty){}
  // GetTask gets a task(k8s cron job) by name within an existing namespace
  rpc GetTask(Ref) returns(Task){}
  // ListTasks lists all tasks(k8s cron jobs) within an existing namespace
  rpc ListTasks(Namespace) returns(Tasks){}
  // StreamLogs streams logs from an app/task within an existing namespace.
  // Streams are opened to all replicas & converted into a single stream
  rpc StreamLogs(Ref) returns (stream Log){}
}