syntax = "proto3";

package meshpaas;

option go_package = "meshpaaspb";

import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/any.proto";
import "google/protobuf/empty.proto";
import "github.com/mwitkow/go-proto-validators/validator.proto";

message AuthnRule {
  // json web keys uri ref: https://tools.ietf.org/html/rfc7517
  string jwks_uri =1[(validator.field) = {regex : "^.{1,225}$"}];
  // issuer jwt claim ref: https://tools.ietf.org/html/rfc7519#section-4.1.1
  string issuer =2[(validator.field) = {regex : "^.{1,225}$"}];
  // issuer jwt claim ref: https://tools.ietf.org/html/rfc7519#section-4.1.1
  repeated string audience =3;
  // serialize jwt payload & write to this header
  string ouput_payload_header =4[(validator.field) = {regex : "^.{1,225}$"}];
}

// the source of an authorization decision
message AuthzSource {
  // allow_namespaces restricts access to traffic coming from a particular namespace
  repeated string allow_namespaces =1;
}

// the subject of an authorization decision
message AuthzSubject {
  // allow_issuers allows one of many issuers sourced from the incoming jwt.claims.iss claim
  repeated string allow_issuers =6;
  // allow_roles allows one of many roles sourced from the incoming jwt.claims.roles claim
  repeated string allow_roles =7;
  // allow_audience allows one of many audiences sourced from the incoming jwt.claims.aud claim
  repeated string allow_audience =8;
}

// the destination of an authorization decision
message AuthzDestination {
  // restricts access to one of many paths
  repeated string allow_paths =2;
  // restricts access to one of many hosts
  repeated string allow_hosts =3;
  // restricts access to one of many methods
  repeated string allow_methods =4;
  // restricts access to one of many ports
  repeated string allow_ports =5;
}

// At least on AuthzRule rule must pass for a request to reach its final destination(an application) in the service mesh
message AuthzRule {
  // source restricts access based on the source of a request in the service mesh
  AuthzSource source =1;
  // source restricts access based on the destination of a request in the service mesh
  AuthzDestination destination =2;
  // source restricts access based on the subject of a request in the service mesh
  AuthzSubject subject =3;
}

// Authz holds authorization options for an application
message Authz {
  repeated AuthzRule rules =1;
}

// Authn holds authentication options for an application
message Authn {
  repeated AuthnRule rules =1;
}

// SecretType is a secret scoped to a project
enum SecretType {
  OPAQUE =0;
  TLS_CERT_KEY =1;
  DOCKER_CONFIG =2;
}

// SecretInput creates/replaces a secret
message SecretInput {
  // name of the secret
  string name =1[(validator.field) = {regex : "^.{1,225}$"}];
  // secret project
  string project =2[(validator.field) = {regex : "^.{1,225}$"}];
  SecretType type =3;
  // prevent changes to the secret after it is created
  bool immutable =4;
  // k/v map of base64 encoded data
  map<string, string> data =5[(validator.field) = {msg_exists : true}];
}

message Secret {
  // name of the secret
  string name =1[(validator.field) = {regex : "^.{1,225}$"}];
  // secret project
  string project =2[(validator.field) = {regex : "^.{1,225}$"}];
  SecretType type =3;
  // prevent changes to the secret after it is created
  bool immutable =4;
  // k/v map of base64 encoded data
  map<string, string> data =5[(validator.field) = {msg_exists : true}];
}

enum TransportProtocol {
  INVALID_PROTOCOL =0;
  HTTP =1;
  HTTPS =2;
  GRPC =3;
  HTTP2 =4;
  MONGO =5;
  TCP =6;
  TLS =7;
}

enum TLSmode {
  PASSTHROUGH = 0;
  SIMPLE = 1;
  MUTUAL = 2;
  AUTO_PASSTHROUGH = 3;
  ISTIO_MUTUAL = 4;
};

message ServerTLSSettings {
  bool https_redirect = 1;
  TLSmode mode = 2;
  string credential_name = 3;
  repeated string subject_alt_names = 4;
  repeated string verify_certificate_spki = 5;
  repeated string verify_certificate_hash = 6;
  repeated string cipher_suites = 7;
}

message GatewayListener {
  uint32 port =1[(validator.field) = {int_gt : 0}];
  string name =2[(validator.field) = {regex : "^.{1,225}$"}];
  TransportProtocol protocol =3[(validator.field) = {int_gt : 0}];
  repeated string hosts =4[(validator.field) = {repeated_count_min : 0}];
  ServerTLSSettings tls_config =5;
}

message Gateway {
  // name of the gateway
  string name =1;
  // gateway's project
  string project =2;
  repeated GatewayListener listeners = 3;
}

message GatewayInput {
  // name of the gateway
  string name =1[(validator.field) = {regex : "^.{1,225}$"}];
  // gateway's project
  string project =2[(validator.field) = {regex : "^.{1,225}$"}];
  repeated GatewayListener listeners = 3;
}

// HTTPRoute is a single http route(istio HttpRoute)
message HTTPRoute {
  string name =1[(validator.field) = {regex : "^.{1,225}$"}];
  uint32 port =2[(validator.field) = {int_gt : 0}];
  string path_prefix =3;
  string rewrite_uri = 5;
  // The list of origins that are allowed to perform CORS requests
  repeated string allow_origins =6;
  // The list of methods that are allowed to perform CORS requests
  repeated string allow_methods =7;
  // The list of headers that are allowed to perform CORS requests
  repeated string allow_headers =8;
  // The list of origins that are allowed to perform CORS requests
  repeated string expose_headers =9;
  // adds `Access-Control-Allow-Credentials` header
  bool allow_credentials =10;
}

message Networking {
  // gateways to bind to
  repeated string gateways =1;
  // host names to bind to
  repeated string hosts =2;
  // export service to other applications in other projects
  bool export =3;
  // http route matchers/configurations
  repeated HTTPRoute http_routes =4;
}

// Container is a single docker container
message Container {
  // name of the container
  string name =1[(validator.field) = {regex : "^.{1,225}$"}];
  // docker image of container
  string image =2[(validator.field) = {regex : "^.{1,225}$"}];
  // args are arguments given to the docker image at startup
  repeated string args =3;
  // k/v map of environmental variables
  map<string, string> env =4;
  // k/v map of ports to expose ex: http: 80 https: 443
  map<string, uint32> ports =5[(validator.field) = {msg_exists : true}];
}

// App is a stateless application
message App {
  // name of the application
  string name =1[(validator.field) = {regex : "^.{1,225}$"}];
  // application project
  string project =2[(validator.field) = {regex : "^.{1,225}$"}];
  repeated Container containers =3[(validator.field) = {msg_exists : true}];
  // number of deployment replicas
  uint32 replicas =8;
  // gateway/service-mesh networking
  Networking networking =11[(validator.field) = {msg_exists : true}];
  // application authentication options
  Authn authentication =12[(validator.field) = {msg_exists : true}];
  // application authorization options
  Authz authorization =13[(validator.field) = {msg_exists : true}];
  // status tracks the state of the application during it's lifecycle
  AppStatus status =20[(validator.field) = {msg_exists : true}];
}


// Task is scheduled cron job
message Task {
  // name of the task
  string name =1[(validator.field) = {regex : "^.{1,225}$"}];
  // task project
  string project =2[(validator.field) = {regex : "^.{1,225}$"}];
  repeated Container containers =3[(validator.field) = {msg_exists : true}];
  // schedule is the cron schedule: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/
  string schedule = 7[(validator.field) = {regex : "^.{1,225}$"}];
  // completions is the number of times to execute the task. If completions = 0, the task will run forever
  uint32 completions = 8;
}

// TaskInput creates/updates a task(cron job)
message TaskInput {
  // name of the task
  string name =1[(validator.field) = {regex : "^.{1,225}$"}];
  // task project
  string project =2[(validator.field) = {regex : "^.{1,225}$"}];
  repeated Container containers =3[(validator.field) = {msg_exists : true}];
  // schedule is the cron schedule: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/
  string schedule = 7[(validator.field) = {regex : "^.{1,225}$"}];
  // completions is the number of times to execute the task. If completions = 0, the task will run forever
  uint32 completions = 8;
}

// AppInput creates/replaces an app
message AppInput {
  // name of the application
  string name =1[(validator.field) = {regex : "^.{1,225}$"}];
  // application project
  string project =2[(validator.field) = {regex : "^.{1,225}$"}];
  repeated Container containers =3[(validator.field) = {msg_exists : true}];
  // number of deployment replicas
  uint32 replicas =7;
  Networking networking =10[(validator.field) = {msg_exists : true}];
  // application authentication options
  Authn authentication =12;
  // application authorization options
  Authz authorization =13[(validator.field) = {msg_exists : true}];
}

// Ref is a pointer to a resource
message Ref {
  // name of the resource
  string name =1[(validator.field) = {regex : "^.{1,225}$"}];
  // resource's project
  string project =2[(validator.field) = {regex : "^.{1,225}$"}];
}

// Replica tracks the state/status of an individual replica of an application
message Replica {
  string phase =1;
  string condition =2;
  string reason =3;
}

// AppStatus tracks the status of an application
message AppStatus {
  repeated Replica replicas =1;
}

message Log {
  string message =1;
}

message Apps {
  repeated App applications =1;
}

message Tasks {
  repeated Task tasks =1;
}

// Project creates/replaces a project(k8s namespace)
message ProjectInput {
  string name =1[(validator.field) = {regex : "^.{1,225}$"}];
}

// Project is a reference to a project(k8s namespace)
message Project {
  string name =1;
}

// ProjectRef is a reference to an existing project(k8s namespace)
message ProjectRef {
  string name =1[(validator.field) = {regex : "^.{1,225}$"}];
}

message Projects {
  repeated string projects =1;
}


// MeshPaasService is a platform as a service backed by Istio service mesh
service MeshPaasService {
  rpc CreateProject(ProjectInput) returns(Project){}
  // ListProjects lists all projects(k8s namespace) created by meshpaas
  rpc ListProjects(google.protobuf.Empty) returns(Projects){}
  // DeleteProject deletes a project(k8s namespace) & all its resources
  rpc DeleteProject(ProjectRef) returns(google.protobuf.Empty){}
  // GetProject gets an existing project(k8s namespace)
  rpc GetProject(ProjectRef) returns(Project){}
  // UpdateProject updates an existing project(k8s namespace)
  rpc UpdateProject(ProjectInput) returns(Project){}

  // CreateApp creates a new stateless application(k8s deployment & service) within a single project(k8s namespace)
  // the project will automatically be created if one does not already exist
  rpc CreateApp(AppInput) returns(App){}
  // UpdateApp replaces an existing stateless application(k8s deployment & service) within an existing project(k8s namespace)
  rpc UpdateApp(AppInput) returns(App){}
  // DeleteApp deletes a single stateless application(k8s deployment & service) within an existing project
  rpc DeleteApp(Ref) returns(google.protobuf.Empty){}
  // GetApp gets an app by name within an existing project
  rpc GetApp(Ref) returns(App){}
  // ListApps lists all apps within an existing project
  rpc ListApps(ProjectRef) returns(Apps){}

  // CreateTask creates a new task(k8s cron job) within a single project(k8s namespace)
  // the project will automatically be created if one does not already exist
  rpc CreateTask(TaskInput) returns(Task){}
  // UpdateTask replaces an existing task(k8s cron job) within an existing project(k8s namespace)
  rpc UpdateTask(TaskInput) returns(Task){}
  // DeleteTask deletes a single task(k8s cron job) within an existing project
  rpc DeleteTask(Ref) returns(google.protobuf.Empty){}
  // GetTask gets a task(k8s cron job) by name within an existing project
  rpc GetTask(Ref) returns(Task){}
  // ListTasks lists all tasks(k8s cron jobs) within an existing project
  rpc ListTasks(ProjectRef) returns(Tasks){}


  // CreateGateway creates a new gateway(istio gateway) within a single project(k8s namespace)
  // the project will automatically be created if one does not already exist
  rpc CreateGateway(GatewayInput) returns(Gateway){}
  // UpdateGateway replaces an existing gateway(istio gateway) within an existing project(k8s namespace)
  rpc UpdateGateway(GatewayInput) returns(Gateway){}
  // DeleteGateway deletes a single gateway(istio gateway) within an existing project
  rpc DeleteGateway(Ref) returns(google.protobuf.Empty){}
  // GetGateway gets a gateway(istio gateway) by name within an existing project
  rpc GetGateway(Ref) returns(Gateway){}


  // CreateSecret creates a new secret(k8s secret) within a single project(k8s namespace)
  // the project will automatically be created if one does not already exist
  rpc CreateSecret(SecretInput) returns(Secret){}
  // UpdateSecret replaces an existing secret(k8s secret) within an existing project(k8s namespace)
  rpc UpdateSecret(SecretInput) returns(Secret){}
  // DeleteSecret deletes a single secret(k8s secret) within an existing project
  rpc DeleteSecret(Ref) returns(google.protobuf.Empty){}
  // GetSecret gets a secret(k8s secret) by name within an existing project
  rpc GetSecret(Ref) returns(Secret){}

  // StreamLogs streams logs from an app/task within an existing project.
  // Streams are opened to all replicas & converted into a single stream
  rpc StreamLogs(Ref) returns (stream Log){}
}